{"version":3,"sources":["use-swr-document.ts"],"names":["getDocument","path","empty","object","parseDates","ignoreFirestoreDocumentSnapshotField","fuego","db","doc","get","then","docData","data","serverTimestamps","isDev","exists","id","hasPendingWrites","console","warn","metadata","__snapshot","undefined","collection","split","pop","join","collectionCache","getSWRKeysFromCollectionPath","forEach","key","currentState","array","some","map","document","createListenerAsync","Promise","resolve","unsubscribe","onSnapshot","filter","Boolean","initialData","useDocument","options","unsubscribeRef","listen","opts","refreshInterval","refreshWhenHidden","refreshWhenOffline","revalidateOnFocus","revalidateOnReconnect","swrOptions","shouldListen","current","datesToParse","shouldIgnoreSnapshot","swr","isValidating","revalidate","connectedMutate","mutate","error","mounted","revalidateRef","set","prevState","merge","update","connectedDelete","loading","deleteDocument"],"mappings":"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","sourcesContent":["import useSWR, { mutate, ConfigInterface } from 'swr'\nimport { SetOptions } from '@firebase/firestore-types'\nimport { fuego } from '../context'\nimport { useRef, useEffect, useCallback } from 'react'\nimport { empty } from '../helpers/empty'\nimport { Document } from '../types/Document'\nimport { collectionCache } from '../classes/Cache'\nimport { isDev } from '../helpers/is-dev'\nimport { withDocumentDatesParsed } from '../helpers/doc-date-parser'\nimport { deleteDocument } from './static-mutations'\n\ntype Options<Doc extends Document = Document> = {\n  /**\n   * If `true`, sets up a real-time subscription to the Firestore backend.\n   *\n   * Default: `false`\n   */\n  listen?: boolean\n  /**\n   * An array of key strings that indicate where there will be dates in the document.\n   *\n   * Example: if your dates are in the `lastUpdated` and `user.createdAt` fields, then pass `{parseDates: [\"lastUpdated\", \"user.createdAt\"]}`.\n   *\n   * This will automatically turn all Firestore dates into JS Date objects, removing the need to do `.toDate()` on your dates.\n   */\n  parseDates?: (\n    | string\n    | keyof Omit<Doc, 'id' | 'exists' | 'hasPendingWrites' | '__snapshot'>\n  )[]\n  /**\n   * If `true`, doc returned in `data` will not include the firestore `__snapshot` field.\n   *\n   * If `false`, it will include a `__snapshot` field. This lets you access the document snapshot, but makes the document not JSON serializable.\n   *\n   * Default: `true`\n   */\n  ignoreFirestoreDocumentSnapshotField?: boolean\n} & ConfigInterface<Doc | null>\n\ntype ListenerReturnType<Doc extends Document = Document> = {\n  initialData: Doc\n  unsubscribe: ReturnType<ReturnType<typeof fuego['db']['doc']>['onSnapshot']>\n}\n\nexport const getDocument = async <Doc extends Document = Document>(\n  path: string,\n  {\n    parseDates,\n    ignoreFirestoreDocumentSnapshotField = true,\n  }: {\n    parseDates?: (\n      | string\n      | keyof Omit<Doc, 'id' | 'exists' | 'hasPendingWrites' | '__snapshot'>\n    )[]\n    /**\n     * If `true`, doc returned in `data` will not include the firestore `__snapshot` field.\n     *\n     * If `false`, it will include a `__snapshot` field. This lets you access the document snapshot, but makes the document not JSON serializable.\n     *\n     * Default: `true`\n     */\n    ignoreFirestoreDocumentSnapshotField?: boolean\n  } = empty.object\n) => {\n  const data = await fuego.db\n    .doc(path)\n    .get()\n    .then(doc => {\n      const docData =\n        doc.data({\n          serverTimestamps: 'estimate',\n        }) ?? empty.object\n      if (\n        isDev &&\n        // @ts-ignore\n        (docData.exists || docData.id || docData.hasPendingWrites)\n      ) {\n        console.warn(\n          '[get-document] warning: Your document, ',\n          doc.id,\n          ' is using one of the following reserved fields: [exists, id, hasPendingWrites]. These fields are reserved. Please remove them from your documents.'\n        )\n      }\n      return withDocumentDatesParsed(\n        ({\n          ...docData,\n          id: doc.id,\n          exists: doc.exists,\n          hasPendingWrites: doc.metadata.hasPendingWrites,\n          __snapshot: ignoreFirestoreDocumentSnapshotField ? undefined : doc,\n        } as unknown) as Doc,\n        parseDates\n      )\n    })\n\n  // update the document in any collections listening to the same document\n  let collection: string | string[] = path.split(`/${data.id}`)\n\n  collection.pop() // remove last item, which is the /id\n  collection = collection.join('/') // rejoin the path\n  if (collection) {\n    collectionCache.getSWRKeysFromCollectionPath(collection).forEach(key => {\n      mutate(\n        key,\n        (currentState: Doc[] = empty.array): Doc[] => {\n          // don't mutate the current state if it doesn't include this doc\n          if (!currentState.some(doc => doc.id === data.id)) {\n            return currentState\n          }\n          return currentState.map(document => {\n            if (document.id === data.id) {\n              return data\n            }\n            return document\n          })\n        },\n        false\n      )\n    })\n  }\n\n  return data\n}\n\nconst createListenerAsync = async <Doc extends Document = Document>(\n  path: string,\n  {\n    parseDates,\n    ignoreFirestoreDocumentSnapshotField = true,\n  }: {\n    parseDates?: (\n      | string\n      | keyof Omit<Doc, 'id' | 'exists' | 'hasPendingWrites' | '__snapshot'>\n    )[]\n    /**\n     * If `true`, `data` will not include the firestore `__snapshot` field. You might want this if you need your data to be JSON serializable.\n     *\n     * Default: `false`\n     */\n    ignoreFirestoreDocumentSnapshotField?: boolean\n  } = {}\n): Promise<ListenerReturnType<Doc>> => {\n  return await new Promise(resolve => {\n    const unsubscribe = fuego.db.doc(path).onSnapshot(doc => {\n      const docData = doc.data() ?? empty.object\n      const data = withDocumentDatesParsed<Doc>(\n        ({\n          ...docData,\n          id: doc.id,\n          exists: doc.exists,\n          hasPendingWrites: doc.metadata.hasPendingWrites,\n          __snapshot: ignoreFirestoreDocumentSnapshotField ? undefined : doc,\n        } as unknown) as Doc,\n        parseDates\n      )\n      mutate(path, data, false)\n      if (\n        isDev &&\n        // @ts-ignore\n        (docData.exists || docData.id || docData.hasPendingWrites)\n      ) {\n        console.warn(\n          '[use-document] warning: Your document, ',\n          doc.id,\n          ' is using one of the following reserved fields: [exists, id, hasPendingWrites]. These fields are reserved. Please remove them from your documents.'\n        )\n      }\n\n      // update the document in any collections listening to the same document\n      let collection: string | string[] = path\n        .split(`/${doc.id}`)\n        .filter(Boolean)\n      collection.pop() // remove last item, which is the /id\n      collection = collection.join('/')\n\n      if (collection) {\n        collectionCache\n          .getSWRKeysFromCollectionPath(collection)\n          .forEach(key => {\n            mutate(\n              key,\n              (currentState: Doc[] = empty.array): Doc[] => {\n                // don't mutate the current state if it doesn't include this doc\n                if (!currentState.some(doc => doc.id && doc.id === data.id)) {\n                  return currentState\n                }\n                return currentState.map(document => {\n                  if (document.id === data.id) {\n                    return data\n                  }\n                  return document\n                })\n              },\n              false\n            )\n          })\n      }\n\n      // the first time the listener fires, we resolve the promise with initial data\n      resolve({\n        initialData: data,\n        unsubscribe,\n      })\n    })\n  })\n}\n\nexport const useDocument = <\n  Data extends object = {},\n  Doc extends Document = Document<Data>\n>(\n  path: string | null,\n  options: Options<Doc> = empty.object\n) => {\n  const unsubscribeRef = useRef<ListenerReturnType['unsubscribe'] | null>(null)\n  const {\n    listen = false,\n    parseDates,\n    ignoreFirestoreDocumentSnapshotField = true,\n    ...opts\n  } = options\n\n  // if we're listening, the firestore listener handles all revalidation\n  const {\n    refreshInterval = listen ? 0 : undefined,\n    refreshWhenHidden = listen ? false : undefined,\n    refreshWhenOffline = listen ? false : undefined,\n    revalidateOnFocus = listen ? false : undefined,\n    revalidateOnReconnect = listen ? false : undefined,\n  } = options\n\n  const swrOptions = {\n    ...opts,\n    refreshInterval,\n    refreshWhenHidden,\n    refreshWhenOffline,\n    revalidateOnFocus,\n    revalidateOnReconnect,\n  }\n\n  // we move listen to a Ref\n  // why? because we shouldn't have to include \"listen\" in the key\n  // if we do, then calling mutate() won't be consistent for all\n  // documents with the same path.\n  const shouldListen = useRef(listen)\n  useEffect(() => {\n    shouldListen.current = listen\n  }, [listen])\n\n  const datesToParse = useRef(parseDates)\n  useEffect(() => {\n    datesToParse.current = parseDates\n  }, [parseDates])\n\n  const shouldIgnoreSnapshot = useRef(ignoreFirestoreDocumentSnapshotField)\n  useEffect(() => {\n    shouldIgnoreSnapshot.current = ignoreFirestoreDocumentSnapshotField\n  }, [ignoreFirestoreDocumentSnapshotField])\n\n  const swr = useSWR<Doc | null>(\n    path,\n    async (path: string) => {\n      if (shouldListen.current) {\n        if (unsubscribeRef.current) {\n          unsubscribeRef.current()\n          unsubscribeRef.current = null\n        }\n        const { unsubscribe, initialData } = await createListenerAsync<Doc>(\n          path,\n          {\n            parseDates: datesToParse.current,\n            ignoreFirestoreDocumentSnapshotField: shouldIgnoreSnapshot.current,\n          }\n        )\n        unsubscribeRef.current = unsubscribe\n        return initialData\n      }\n      const data = await getDocument<Doc>(path, {\n        parseDates: datesToParse.current,\n        ignoreFirestoreDocumentSnapshotField: shouldIgnoreSnapshot.current,\n      })\n      return data\n    },\n    swrOptions\n  )\n\n  const { data, isValidating, revalidate, mutate: connectedMutate, error } = swr\n\n  // if listen changes,\n  // we run revalidate.\n  // This triggers SWR to fetch again\n  // Why? because we don't want to put listen or memoQueryString\n  // in the useSWR key. If we did, then we couldn't mutate\n  // based on path. If we had useSWR(['users', { where: ['name', '==, 'fernando']}]),\n  // and we updated the proper `user` dictionary, it wouldn't mutate, because of\n  // the key.\n  // thus, we move the `listen` and `queryString` options to refs passed to `useSWR`,\n  // and we call `revalidate` if either of them change.\n  const mounted = useRef(false)\n  useEffect(() => {\n    if (mounted.current) revalidateRef.current()\n    else mounted.current = true\n  }, [listen])\n\n  // this MUST be after the previous effect to avoid duplicate initial validations.\n  // only happens on updates, not initial mount.\n  const revalidateRef = useRef(swr.revalidate)\n  useEffect(() => {\n    revalidateRef.current = swr.revalidate\n  })\n\n  useEffect(() => {\n    return () => {\n      // clean up listener on unmount if it exists\n      if (unsubscribeRef.current) {\n        unsubscribeRef.current()\n        unsubscribeRef.current = null\n      }\n    }\n    // should depend on the path, and listen being the same...\n  }, [path, listen])\n\n  /**\n   * `set(data, SetOptions?)`: Extends the `firestore` document `set` function.\n   * - You can call this when you want to edit your document.\n   * - It also updates the local cache using SWR's `mutate`. This will prove highly convenient over the regular Firestore `set` function.\n   * - The second argument is the same as the second argument for [Firestore `set`](https://firebase.google.com/docs/firestore/manage-data/add-data#set_a_document).\n   */\n  const set = useCallback(\n    (data: Partial<Data>, options?: SetOptions) => {\n      if (!listen) {\n        // we only update the local cache if we don't have a listener set up\n        // Why? firestore handles this for us for listeners.\n        // @ts-ignore\n        connectedMutate((prevState = empty.object) => {\n          // default we set merge to be false. this is annoying, but follows Firestore's preference.\n          if (!options?.merge) return data\n          return {\n            ...prevState,\n            ...data,\n          }\n        })\n      }\n      if (!path) return null\n      return fuego.db.doc(path).set(data, options)\n    },\n    [path, listen, connectedMutate]\n  )\n\n  /**\n   * - `update(data)`: Extends the Firestore document [`update` function](https://firebase.google.com/docs/firestore/manage-data/add-data#update-data).\n   * - It also updates the local cache using SWR's `mutate`. This will prove highly convenient over the regular `set` function.\n   */\n  const update = useCallback(\n    (data: Partial<Data>) => {\n      if (!listen) {\n        // we only update the local cache if we don't have a listener set up\n        // @ts-ignore\n        connectedMutate((prevState = empty.object) => {\n          return {\n            ...prevState,\n            ...data,\n          }\n        })\n      }\n      if (!path) return null\n      return fuego.db.doc(path).update(data)\n    },\n    [listen, path, connectedMutate]\n  )\n\n  const connectedDelete = useCallback(() => {\n    return deleteDocument(path, listen)\n  }, [path, listen])\n\n  return {\n    data,\n    isValidating,\n    revalidate,\n    mutate: connectedMutate,\n    error,\n    set,\n    update,\n    loading: !data && !error,\n    deleteDocument: connectedDelete,\n  }\n}\n\n// const useSubscription = (path: string) => {\n//   const unsubscribeRef = useRef<\n//     ReturnType<typeof createListener>['unsubscribe'] | null\n//   >(null)\n\n//   const swr = useSWR([path], path => {\n//     const { unsubscribe, latestData } = createListener(path)\n//     unsubscribeRef.current = unsubscribe\n//     return latestData()\n//   })\n\n//   useEffect(() => {\n//     return () => {\n//       if (unsubscribeRef.current) {\n//         unsubscribeRef.current()\n//       }\n//     }\n//   }, [path])\n//   return swr\n// }\n"]}