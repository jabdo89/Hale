{"version":3,"sources":["Cache.ts"],"names":["CollectionCache","collections","path","isCollection","trim","split","filter","Boolean","length","console","error","map","key","keyItem","empty","array","queryString","collectionAlreadyExistsInCache","some","collectionCache"],"mappings":"gjBAAA,uC,4yBAeMA,CAAAA,e,YAEJ,0BAAc,4GACZ,KAAKC,WAAL,CAAmB,EAAnB,CACD,C,2HAE4BC,I,CAAc,kDACzC,GAAMC,CAAAA,YAAY,CAChBD,IAAI,CACDE,IADH,GAEGC,KAFH,CAES,GAFT,EAGGC,MAHH,CAGUC,OAHV,EAGmBC,MAHnB,CAIE,CAJF,GAKA,CANF,CAOA,GAAI,CAACL,YAAL,CAAmB,CACjBM,OAAO,CAACC,KAAR,kHAC4GR,IAD5G,OAGD,CACD,qDACE,KAAKD,WAAL,CAAiBC,IAAjB,CADF,iDACE,uBACIS,GADJ,CACQ,kBAAGC,CAAAA,GAAH,MAAGA,GAAH,OAEJA,CAAAA,GAAG,CAACN,MAAJ,CAAW,SAAAO,OAAO,QAAI,OAAOA,CAAAA,OAAP,GAAmB,QAAvB,EAAlB,CAFI,EADR,EAKGP,MALH,CAKUC,OALV,CADF,+DAMwBO,aAAMC,KAN9B,CAQD,C,kEACoBb,I,CAAcc,W,CAAsB,4BACvD,GAAMC,CAAAA,8BAA8B,yBAAG,KAAKhB,WAAL,CAAiBC,IAAjB,CAAH,iDAAG,uBAAwBgB,IAAxB,CACrC,mBAAGN,CAAAA,GAAH,OAAGA,GAAH,OAAaA,CAAAA,GAAG,CAAC,CAAD,CAAH,GAAWV,IAAX,EAAmBU,GAAG,CAAC,CAAD,CAAH,GAAWI,WAA3C,EADqC,CAAvC,CAGA,GAAI,CAACC,8BAAL,CAAqC,4BACnC,KAAKhB,WAAL,kBACK,KAAKA,WADV,iCAEGC,IAFH,mEAGQ,KAAKD,WAAL,CAAiBC,IAAjB,CAHR,iEAGkCY,aAAMC,KAHxC,GAII,CACEH,GAAG,CAAE,CAACV,IAAD,CAAOc,WAAP,CADP,CAJJ,KASD,CACD,MAAO,MAAKf,WAAZ,CACD,C,+BAGI,GAAMkB,CAAAA,eAAe,CAAG,GAAInB,CAAAA,eAAJ,EAAxB,C","sourcesContent":["import { empty } from '../helpers/empty'\n\ntype Collections = {\n  [path: string]: {\n    key: [string, string | undefined] // [path, queryString]\n  }[]\n}\n\n/**\n * Collection cache\n *\n * This helps us keep track of which collections have been created.\n *\n * Whenever we edit a document, we then check the collection cache to see which collections we should also update.\n */\nclass CollectionCache {\n  private collections: Collections\n  constructor() {\n    this.collections = {}\n  }\n\n  getSWRKeysFromCollectionPath(path: string) {\n    const isCollection =\n      path\n        .trim()\n        .split('/')\n        .filter(Boolean).length %\n        2 !==\n      0\n    if (!isCollection) {\n      console.error(\n        `[fuego-swr-keys-from-collection-path] error: Passed a path that was not a collection to useCollection: ${path}.`\n      )\n    }\n    return (\n      this.collections[path]\n        ?.map(({ key }) =>\n          // if the queryString is undefined, take it out of the array\n          key.filter(keyItem => typeof keyItem === 'string')\n        )\n        .filter(Boolean) ?? empty.array\n    )\n  }\n  addCollectionToCache(path: string, queryString?: string) {\n    const collectionAlreadyExistsInCache = this.collections[path]?.some(\n      ({ key }) => key[0] === path && key[1] === queryString\n    )\n    if (!collectionAlreadyExistsInCache) {\n      this.collections = {\n        ...this.collections,\n        [path]: [\n          ...(this.collections[path] ?? empty.array),\n          {\n            key: [path, queryString],\n          },\n        ],\n      }\n    }\n    return this.collections\n  }\n}\n\nexport const collectionCache = new CollectionCache()\n"]}