{"version":3,"sources":["static-mutations.ts"],"names":["revalidateDocument","path","revalidateCollection","promises","collectionCache","getSWRKeysFromCollectionPath","forEach","key","push","Promise","all","set","data","options","ignoreLocalMutation","isDocument","trim","split","filter","Boolean","length","Error","JSON","stringify","prevState","empty","object","merge","collection","docId","pop","join","currentState","array","some","doc","id","map","document","fuego","db","update","deleteDocument","delete"],"mappings":"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","sourcesContent":["import { mutate } from 'swr'\nimport { SetOptions } from '@firebase/firestore-types'\nimport { fuego } from '../context'\nimport { empty } from '../helpers/empty'\nimport { collectionCache } from '../classes/Cache'\nimport { Document } from '../types/Document'\n\n/**\n * Function that, when called, refreshes all queries that match this document path.\n *\n * This can be useful for a pull to refresh that isn't on the same screen as the `useCollection` hook, for example.\n */\nconst revalidateDocument = (path: string) => {\n  return mutate(path)\n}\n\n/**\n * Function that, when called, refreshes all queries that match this document path.\n *\n * This can be useful for a pull to refresh that isn't on the same screen as the `useCollection` hook, for example.\n */\nconst revalidateCollection = (path: string) => {\n  const promises: Promise<any>[] = []\n  collectionCache.getSWRKeysFromCollectionPath(path).forEach(key => {\n    promises.push(mutate(key))\n  })\n  return Promise.all(promises)\n}\n\nconst set = <Data extends object = {}, Doc extends Document = Document<Data>>(\n  path: string | null,\n  data: Partial<Data>,\n  options?: SetOptions,\n  /**\n   * If true, the local cache won't be updated. Default `false`.\n   */\n  ignoreLocalMutation = false\n) => {\n  if (path === null) return null\n\n  const isDocument =\n    path\n      .trim()\n      .split('/')\n      .filter(Boolean).length %\n      2 ===\n    0\n\n  if (!isDocument)\n    throw new Error(\n      `[@nandorojo/swr-firestore] error: called set() function with path: ${path}. This is not a valid document path. \n      \ndata: ${JSON.stringify(data)}`\n    )\n\n  if (!ignoreLocalMutation) {\n    mutate(\n      path,\n      (prevState = empty.object) => {\n        if (!options?.merge) return data\n        return {\n          ...prevState,\n          ...data,\n        }\n      },\n      false\n    )\n  }\n\n  let collection: string | string[] = path.split(`/`).filter(Boolean)\n  const docId = collection.pop() // remove last item, which is the /doc-id\n  collection = collection.join('/')\n\n  collectionCache.getSWRKeysFromCollectionPath(collection).forEach(key => {\n    mutate(\n      key,\n      (currentState: Doc[] = empty.array) => {\n        // don't mutate the current state if it doesn't include this doc\n        // why? to prevent creating a new reference of the state\n        // creating a new reference could trigger unnecessary re-renders\n        if (!currentState.some(doc => doc.id === docId)) {\n          return currentState\n        }\n        return currentState.map((document = empty.object as Doc) => {\n          if (document.id === docId) {\n            if (!options?.merge) return document\n            return { ...document, ...data }\n          }\n          return document\n        })\n      },\n      false\n    )\n  })\n\n  return fuego.db.doc(path).set(data, options)\n}\n\nconst update = <\n  Data extends object = {},\n  Doc extends Document = Document<Data>\n>(\n  path: string | null,\n  data: Partial<Data>,\n  /**\n   * If true, the local cache won't be updated. Default `false`.\n   */\n  ignoreLocalMutation = false\n) => {\n  if (path === null) return null\n  const isDocument =\n    path\n      .trim()\n      .split('/')\n      .filter(Boolean).length %\n      2 ===\n    0\n\n  if (!isDocument)\n    throw new Error(\n      `[@nandorojo/swr-firestore] error: called update function with path: ${path}. This is not a valid document path. \n      \ndata: ${JSON.stringify(data)}`\n    )\n\n  if (!ignoreLocalMutation) {\n    mutate(\n      path,\n      (prevState = empty.object) => {\n        return {\n          ...prevState,\n          ...data,\n        }\n      },\n      false\n    )\n  }\n\n  let collection: string | string[] = path.split(`/`).filter(Boolean)\n  const docId = collection.pop() // remove last item, which is the /doc-id\n  collection = collection.join('/')\n\n  collectionCache.getSWRKeysFromCollectionPath(collection).forEach(key => {\n    mutate(\n      key,\n      (currentState: Doc[] = empty.array): Doc[] => {\n        // don't mutate the current state if it doesn't include this doc\n        if (!currentState.some(doc => doc.id === docId)) {\n          return currentState\n        }\n        return currentState.map((document = empty.object as Doc) => {\n          if (document.id === docId) {\n            return { ...document, ...data }\n          }\n          return document\n        })\n      },\n      false\n    )\n  })\n  return fuego.db.doc(path).update(data)\n}\n\nconst deleteDocument = <\n  Data extends object = {},\n  Doc extends Document = Document<Data>\n>(\n  path: string | null,\n  /**\n   * If true, the local cache won't be updated immediately. Default `false`.\n   */\n  ignoreLocalMutation = false\n) => {\n  if (path === null) return null\n\n  const isDocument =\n    path\n      .trim()\n      .split('/')\n      .filter(Boolean).length %\n      2 ===\n    0\n\n  if (!isDocument)\n    throw new Error(\n      `[@nandorojo/swr-firestore] error: called delete() function with path: ${path}. This is not a valid document path.`\n    )\n\n  if (!ignoreLocalMutation) {\n    mutate(path, null, false)\n\n    let collection: string | string[] = path.split(`/`).filter(Boolean)\n    const docId = collection.pop() // remove last item, which is the /doc-id\n    collection = collection.join('/')\n\n    collectionCache.getSWRKeysFromCollectionPath(collection).forEach(key => {\n      mutate(\n        key,\n        (currentState: Doc[] = empty.array) => {\n          // don't mutate the current state if it doesn't include this doc\n          // why? to prevent creating a new reference of the state\n          // creating a new reference could trigger unnecessary re-renders\n          if (!currentState.some(doc => doc && doc.id === docId)) {\n            return currentState\n          }\n          return currentState.filter(document => {\n            if (!document) return false\n            if (document.id === docId) {\n              // delete this doc\n              return false\n            }\n            return true\n          })\n        },\n        false\n      )\n    })\n  }\n\n  return fuego.db.doc(path).delete()\n}\n\nexport { set, update, revalidateDocument, revalidateCollection, deleteDocument }\n"]}